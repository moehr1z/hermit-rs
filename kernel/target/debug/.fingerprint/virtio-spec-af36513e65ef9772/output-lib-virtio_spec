{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1435,"byte_end":1443,"line_start":54,"line_end":54,"column_start":51,"column_end":59,"is_primary":true,"text":[{"text":"                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))","highlight_start":51,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:54:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1435,"byte_end":1443,"line_start":54,"line_end":54,"column_start":51,"column_end":59,"is_primary":true,"text":[{"text":"                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))","highlight_start":51,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:54:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1836,"byte_end":1844,"line_start":68,"line_end":68,"column_start":66,"column_end":74,"is_primary":true,"text":[{"text":"            let ptr = unsafe { self.map(|ptr| ptr.cast::<le32>().byte_add($offset)) };","highlight_start":66,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:68:66\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m68\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m            let ptr = unsafe { self.map(|ptr| ptr.cast::<le32>().byte_add($offset)) };\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1435,"byte_end":1443,"line_start":54,"line_end":54,"column_start":51,"column_end":59,"is_primary":true,"text":[{"text":"                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))","highlight_start":51,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:54:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1435,"byte_end":1443,"line_start":54,"line_end":54,"column_start":51,"column_end":59,"is_primary":true,"text":[{"text":"                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))","highlight_start":51,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:54:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1435,"byte_end":1443,"line_start":54,"line_end":54,"column_start":51,"column_end":59,"is_primary":true,"text":[{"text":"                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))","highlight_start":51,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:54:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1435,"byte_end":1443,"line_start":54,"line_end":54,"column_start":51,"column_end":59,"is_primary":true,"text":[{"text":"                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))","highlight_start":51,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:54:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1435,"byte_end":1443,"line_start":54,"line_end":54,"column_start":51,"column_end":59,"is_primary":true,"text":[{"text":"                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))","highlight_start":51,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:54:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1836,"byte_end":1844,"line_start":68,"line_end":68,"column_start":66,"column_end":74,"is_primary":true,"text":[{"text":"            let ptr = unsafe { self.map(|ptr| ptr.cast::<le32>().byte_add($offset)) };","highlight_start":66,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:68:66\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m68\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m            let ptr = unsafe { self.map(|ptr| ptr.cast::<le32>().byte_add($offset)) };\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1836,"byte_end":1844,"line_start":68,"line_end":68,"column_start":66,"column_end":74,"is_primary":true,"text":[{"text":"            let ptr = unsafe { self.map(|ptr| ptr.cast::<le32>().byte_add($offset)) };","highlight_start":66,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:68:66\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m68\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m            let ptr = unsafe { self.map(|ptr| ptr.cast::<le32>().byte_add($offset)) };\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1836,"byte_end":1844,"line_start":68,"line_end":68,"column_start":66,"column_end":74,"is_primary":true,"text":[{"text":"            let ptr = unsafe { self.map(|ptr| ptr.cast::<le32>().byte_add($offset)) };","highlight_start":66,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:68:66\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m68\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m            let ptr = unsafe { self.map(|ptr| ptr.cast::<le32>().byte_add($offset)) };\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1836,"byte_end":1844,"line_start":68,"line_end":68,"column_start":66,"column_end":74,"is_primary":true,"text":[{"text":"            let ptr = unsafe { self.map(|ptr| ptr.cast::<le32>().byte_add($offset)) };","highlight_start":66,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:68:66\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m68\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m            let ptr = unsafe { self.map(|ptr| ptr.cast::<le32>().byte_add($offset)) };\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1435,"byte_end":1443,"line_start":54,"line_end":54,"column_start":51,"column_end":59,"is_primary":true,"text":[{"text":"                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))","highlight_start":51,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:54:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1836,"byte_end":1844,"line_start":68,"line_end":68,"column_start":66,"column_end":74,"is_primary":true,"text":[{"text":"            let ptr = unsafe { self.map(|ptr| ptr.cast::<le32>().byte_add($offset)) };","highlight_start":66,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:68:66\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m68\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m            let ptr = unsafe { self.map(|ptr| ptr.cast::<le32>().byte_add($offset)) };\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1836,"byte_end":1844,"line_start":68,"line_end":68,"column_start":66,"column_end":74,"is_primary":true,"text":[{"text":"            let ptr = unsafe { self.map(|ptr| ptr.cast::<le32>().byte_add($offset)) };","highlight_start":66,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:68:66\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m68\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m            let ptr = unsafe { self.map(|ptr| ptr.cast::<le32>().byte_add($offset)) };\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1836,"byte_end":1844,"line_start":68,"line_end":68,"column_start":66,"column_end":74,"is_primary":true,"text":[{"text":"            let ptr = unsafe { self.map(|ptr| ptr.cast::<le32>().byte_add($offset)) };","highlight_start":66,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:68:66\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m68\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m            let ptr = unsafe { self.map(|ptr| ptr.cast::<le32>().byte_add($offset)) };\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1435,"byte_end":1443,"line_start":54,"line_end":54,"column_start":51,"column_end":59,"is_primary":true,"text":[{"text":"                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))","highlight_start":51,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:54:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1435,"byte_end":1443,"line_start":54,"line_end":54,"column_start":51,"column_end":59,"is_primary":true,"text":[{"text":"                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))","highlight_start":51,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:54:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1435,"byte_end":1443,"line_start":54,"line_end":54,"column_start":51,"column_end":59,"is_primary":true,"text":[{"text":"                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))","highlight_start":51,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:54:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1435,"byte_end":1443,"line_start":54,"line_end":54,"column_start":51,"column_end":59,"is_primary":true,"text":[{"text":"                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))","highlight_start":51,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:54:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1435,"byte_end":1443,"line_start":54,"line_end":54,"column_start":51,"column_end":59,"is_primary":true,"text":[{"text":"                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))","highlight_start":51,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:54:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1435,"byte_end":1443,"line_start":54,"line_end":54,"column_start":51,"column_end":59,"is_primary":true,"text":[{"text":"                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))","highlight_start":51,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:54:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1435,"byte_end":1443,"line_start":54,"line_end":54,"column_start":51,"column_end":59,"is_primary":true,"text":[{"text":"                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))","highlight_start":51,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:54:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1435,"byte_end":1443,"line_start":54,"line_end":54,"column_start":51,"column_end":59,"is_primary":true,"text":[{"text":"                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))","highlight_start":51,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:54:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1435,"byte_end":1443,"line_start":54,"line_end":54,"column_start":51,"column_end":59,"is_primary":true,"text":[{"text":"                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))","highlight_start":51,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:54:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1435,"byte_end":1443,"line_start":54,"line_end":54,"column_start":51,"column_end":59,"is_primary":true,"text":[{"text":"                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))","highlight_start":51,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:54:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1435,"byte_end":1443,"line_start":54,"line_end":54,"column_start":51,"column_end":59,"is_primary":true,"text":[{"text":"                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))","highlight_start":51,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:54:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1435,"byte_end":1443,"line_start":54,"line_end":54,"column_start":51,"column_end":59,"is_primary":true,"text":[{"text":"                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))","highlight_start":51,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:54:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of unstable library feature 'non_null_convenience'","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using [rustup]).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n\n[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html\n"},"level":"error","spans":[{"file_name":"virtio-spec/src/mmio.rs","byte_start":1435,"byte_end":1443,"line_start":54,"line_end":54,"column_start":51,"column_end":59,"is_primary":true,"text":[{"text":"                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))","highlight_start":51,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2780,"byte_end":2921,"line_start":101,"line_end":105,"column_start":17,"column_end":18,"is_primary":false,"text":[{"text":"                field_impl! {","highlight_start":17,"highlight_end":30},{"text":"                    #[offset($offset)]","highlight_start":1,"highlight_end":39},{"text":"                    #[access($Access)]","highlight_start":1,"highlight_end":39},{"text":"                    $field: $T,","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":2957,"byte_end":17432,"line_start":111,"line_end":459,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"device_register_impl! {","highlight_start":1,"highlight_end":24},{"text":"    /// MMIO Device Registers","highlight_start":1,"highlight_end":30},{"text":"    pub struct DeviceRegisters {","highlight_start":1,"highlight_end":33},{"text":"        /// Magic Value","highlight_start":1,"highlight_end":24},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x74726976","highlight_start":1,"highlight_end":23},{"text":"        /// (a Little Endian equivalent of the “virt” string).","highlight_start":1,"highlight_end":63},{"text":"        #[doc(alias = \"MagicValue\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x000)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        magic_value: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device version number","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// 0x2.","highlight_start":1,"highlight_end":17},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// <div class=\"warning\">","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Legacy devices (see _Virtio Transport Options / Virtio Over MMIO / Legacy interface_) used 0x1.","highlight_start":1,"highlight_end":108},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// </div>","highlight_start":1,"highlight_end":19},{"text":"        #[doc(alias = \"Version\")]","highlight_start":1,"highlight_end":34},{"text":"        #[offset(0x004)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        version: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Device ID","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Device Types_ for possible values.","highlight_start":1,"highlight_end":52},{"text":"        /// Value zero (0x0) is used to","highlight_start":1,"highlight_end":40},{"text":"        /// define a system memory map with placeholder devices at static,","highlight_start":1,"highlight_end":75},{"text":"        /// well known addresses, assigning functions to them depending","highlight_start":1,"highlight_end":72},{"text":"        /// on user's needs.","highlight_start":1,"highlight_end":29},{"text":"        #[doc(alias = \"DeviceID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x008)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_id: Id,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtio Subsystem Vendor ID","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"VendorID\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x00c)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        vendor_id: le32,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing features the device supports","highlight_start":1,"highlight_end":60},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns 32 consecutive flag bits,","highlight_start":1,"highlight_end":73},{"text":"        /// the least significant bit depending on the last value written to","highlight_start":1,"highlight_end":77},{"text":"        /// `DeviceFeaturesSel`. Access to this register returns","highlight_start":1,"highlight_end":65},{"text":"        /// bits `DeviceFeaturesSel`*32 to (`DeviceFeaturesSel`*32)+31, eg.","highlight_start":1,"highlight_end":76},{"text":"        /// feature bits 0 to 31 if `DeviceFeaturesSel` is set to 0 and","highlight_start":1,"highlight_end":72},{"text":"        /// features bits 32 to 63 if `DeviceFeaturesSel` is set to 1.","highlight_start":1,"highlight_end":71},{"text":"        /// Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"DeviceFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x010)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        device_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device (host) features word selection.","highlight_start":1,"highlight_end":51},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 device feature bits","highlight_start":1,"highlight_end":77},{"text":"        /// accessible by reading from `DeviceFeatures`.","highlight_start":1,"highlight_end":57},{"text":"        #[doc(alias = \"DeviceFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x014)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        device_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Flags representing device features understood and activated by the driver","highlight_start":1,"highlight_end":86},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register sets 32 consecutive flag bits, the least significant","highlight_start":1,"highlight_end":90},{"text":"        /// bit depending on the last value written to `DriverFeaturesSel`.","highlight_start":1,"highlight_end":76},{"text":"        ///  Access to this register sets bits `DriverFeaturesSel`*32","highlight_start":1,"highlight_end":70},{"text":"        /// to (`DriverFeaturesSel`*32)+31, eg. feature bits 0 to 31 if","highlight_start":1,"highlight_end":72},{"text":"        /// `DriverFeaturesSel` is set to 0 and features bits 32 to 63 if","highlight_start":1,"highlight_end":74},{"text":"        /// `DriverFeaturesSel` is set to 1. Also see _Basic Facilities of a Virtio Device / Feature Bits_.","highlight_start":1,"highlight_end":108},{"text":"        #[doc(alias = \"DriverFeatures\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x020)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Activated (guest) features word selection","highlight_start":1,"highlight_end":54},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects a set of 32 activated feature","highlight_start":1,"highlight_end":75},{"text":"        /// bits accessible by writing to `DriverFeatures`.","highlight_start":1,"highlight_end":60},{"text":"        #[doc(alias = \"DriverFeaturesSel\")]","highlight_start":1,"highlight_end":44},{"text":"        #[offset(0x024)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        driver_features_sel: le32,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue index","highlight_start":1,"highlight_end":32},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the virtual queue that the","highlight_start":1,"highlight_end":72},{"text":"        /// following operations on `QueueNumMax`, `QueueNum`, `QueueReady`,","highlight_start":1,"highlight_end":77},{"text":"        /// `QueueDescLow`, `QueueDescHigh`, `QueueDriverlLow`, `QueueDriverHigh`,","highlight_start":1,"highlight_end":83},{"text":"        /// `QueueDeviceLow`, `QueueDeviceHigh` and `QueueReset` apply to. The index","highlight_start":1,"highlight_end":85},{"text":"        /// number of the first queue is zero (0x0).","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueSel\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x030)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_sel: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Maximum virtual queue size","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from the register returns the maximum size (number of","highlight_start":1,"highlight_end":74},{"text":"        /// elements) of the queue the device is ready to process or","highlight_start":1,"highlight_end":69},{"text":"        /// zero (0x0) if the queue is not available. This applies to the","highlight_start":1,"highlight_end":74},{"text":"        /// queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"QueueNumMax\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x034)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        queue_num_max: le16,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue size","highlight_start":1,"highlight_end":31},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Queue size is the number of elements in the queue.","highlight_start":1,"highlight_end":63},{"text":"        /// Writing to this register notifies the device what size of the","highlight_start":1,"highlight_end":74},{"text":"        /// queue the driver will use. This applies to the queue selected by","highlight_start":1,"highlight_end":77},{"text":"        /// writing to `QueueSel`.","highlight_start":1,"highlight_end":35},{"text":"        #[doc(alias = \"QueueNum\")]","highlight_start":1,"highlight_end":35},{"text":"        #[offset(0x038)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_num: le16,","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue ready bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing one (0x1) to this register notifies the device that it can","highlight_start":1,"highlight_end":79},{"text":"        /// execute requests from this virtual queue. Reading from this register","highlight_start":1,"highlight_end":81},{"text":"        /// returns the last value written to it. Both read and write","highlight_start":1,"highlight_end":70},{"text":"        /// accesses apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":75},{"text":"        #[doc(alias = \"QueueReady\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x044)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_ready: bool,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Queue notifier","highlight_start":1,"highlight_end":27},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value to this register notifies the device that","highlight_start":1,"highlight_end":70},{"text":"        /// there are new buffers to process in a queue.","highlight_start":1,"highlight_end":57},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has not been negotiated,","highlight_start":1,"highlight_end":69},{"text":"        /// the value written is the queue index.","highlight_start":1,"highlight_end":50},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// When VIRTIO_F_NOTIFICATION_DATA has been negotiated,","highlight_start":1,"highlight_end":65},{"text":"        /// the `Notification data` value has the following format:","highlight_start":1,"highlight_end":68},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// ```c","highlight_start":1,"highlight_end":17},{"text":"        /// le32 {","highlight_start":1,"highlight_end":19},{"text":"        ///   vqn : 16;","highlight_start":1,"highlight_end":24},{"text":"        ///   next_off : 15;","highlight_start":1,"highlight_end":29},{"text":"        ///   next_wrap : 1;","highlight_start":1,"highlight_end":29},{"text":"        /// };","highlight_start":1,"highlight_end":15},{"text":"        /// ```","highlight_start":1,"highlight_end":16},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// See _Virtqueues / Driver notifications_","highlight_start":1,"highlight_end":52},{"text":"        /// for the definition of the components.","highlight_start":1,"highlight_end":50},{"text":"        #[doc(alias = \"QueueNotify\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x050)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_notify: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt status","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a bit mask of events that","highlight_start":1,"highlight_end":73},{"text":"        /// caused the device interrupt to be asserted.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"InterruptStatus\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x060)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        interrupt_status: InterruptStatus,","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Interrupt acknowledge","highlight_start":1,"highlight_end":34},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing a value with bits set as defined in `InterruptStatus`","highlight_start":1,"highlight_end":74},{"text":"        /// to this register notifies the device that events causing","highlight_start":1,"highlight_end":69},{"text":"        /// the interrupt have been handled.","highlight_start":1,"highlight_end":45},{"text":"        #[doc(alias = \"InterruptACK\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x064)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        interrupt_ack: InterruptStatus,","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Device status","highlight_start":1,"highlight_end":26},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns the current device status","highlight_start":1,"highlight_end":73},{"text":"        /// flags.","highlight_start":1,"highlight_end":19},{"text":"        /// Writing non-zero values to this register sets the status flags,","highlight_start":1,"highlight_end":76},{"text":"        /// indicating the driver progress. Writing zero (0x0) to this","highlight_start":1,"highlight_end":71},{"text":"        /// register triggers a device reset.","highlight_start":1,"highlight_end":46},{"text":"        /// See also p. _Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization_.","highlight_start":1,"highlight_end":147},{"text":"        #[doc(alias = \"Status\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x070)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        status: DeviceStatus,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescLow\")]","highlight_start":1,"highlight_end":39},{"text":"        #[offset(0x080)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_low: le32,","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Descriptor Area 64 bit long physical address","highlight_start":1,"highlight_end":73},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDescLow`, higher 32 bits to `QueueDescHigh`) notifies","highlight_start":1,"highlight_end":75},{"text":"        /// the device about location of the Descriptor Area of the queue","highlight_start":1,"highlight_end":74},{"text":"        /// selected by writing to `QueueSel` register.","highlight_start":1,"highlight_end":56},{"text":"        #[doc(alias = \"QueueDescHigh\")]","highlight_start":1,"highlight_end":40},{"text":"        #[offset(0x084)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_desc_high: le32,","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x090)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Driver Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDriverLow`, higher 32 bits to `QueueDriverHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Driver Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDriverHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x094)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_driver_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceLow\")]","highlight_start":1,"highlight_end":41},{"text":"        #[offset(0x0a0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_low: le32,","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue's Device Area 64 bit long physical address","highlight_start":1,"highlight_end":69},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to these two registers (lower 32 bits of the address","highlight_start":1,"highlight_end":73},{"text":"        /// to `QueueDeviceLow`, higher 32 bits to `QueueDeviceHigh`) notifies","highlight_start":1,"highlight_end":79},{"text":"        /// the device about location of the Device Area of the queue","highlight_start":1,"highlight_end":70},{"text":"        /// selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":47},{"text":"        #[doc(alias = \"QueueDeviceHigh\")]","highlight_start":1,"highlight_end":42},{"text":"        #[offset(0x0a4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        queue_device_high: le32,","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory id","highlight_start":1,"highlight_end":29},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Writing to this register selects the shared memory region _Basic Facilities of a Virtio Device / Shared Memory Regions_","highlight_start":1,"highlight_end":132},{"text":"        /// following operations on `SHMLenLow`, `SHMLenHigh`,","highlight_start":1,"highlight_end":63},{"text":"        /// `SHMBaseLow` and `SHMBaseHigh` apply to.","highlight_start":1,"highlight_end":53},{"text":"        #[doc(alias = \"SHMSel\")]","highlight_start":1,"highlight_end":33},{"text":"        #[offset(0x0ac)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(WriteOnly)]","highlight_start":1,"highlight_end":29},{"text":"        shm_sel: le32,","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenLow\")]","highlight_start":1,"highlight_end":36},{"text":"        #[offset(0x0b0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_low: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long length","highlight_start":1,"highlight_end":52},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// These registers return the length of the shared memory","highlight_start":1,"highlight_end":67},{"text":"        /// region in bytes, as defined by the device for the region selected by","highlight_start":1,"highlight_end":81},{"text":"        /// the `SHMSel` register.  The lower 32 bits of the length","highlight_start":1,"highlight_end":68},{"text":"        /// are read from `SHMLenLow` and the higher 32 bits from","highlight_start":1,"highlight_end":66},{"text":"        /// `SHMLenHigh`.  Reading from a non-existent","highlight_start":1,"highlight_end":55},{"text":"        /// region (i.e. where the ID written to `SHMSel` is unused)","highlight_start":1,"highlight_end":69},{"text":"        /// results in a length of -1.","highlight_start":1,"highlight_end":39},{"text":"        #[doc(alias = \"SHMLenHigh\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b4)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_len_high: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseLow\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0b8)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_low: le32,","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Shared memory region 64 bit long physical address","highlight_start":1,"highlight_end":62},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// The driver reads these registers to discover the base address","highlight_start":1,"highlight_end":74},{"text":"        /// of the region in physical address space.  This address is","highlight_start":1,"highlight_end":70},{"text":"        /// chosen by the device (or other part of the VMM).","highlight_start":1,"highlight_end":61},{"text":"        /// The lower 32 bits of the address are read from `SHMBaseLow`","highlight_start":1,"highlight_end":72},{"text":"        /// with the higher 32 bits from `SHMBaseHigh`.  Reading","highlight_start":1,"highlight_end":65},{"text":"        /// from a non-existent region (i.e. where the ID written to","highlight_start":1,"highlight_end":69},{"text":"        /// `SHMSel` is unused) results in a base address of","highlight_start":1,"highlight_end":61},{"text":"        /// 0xffffffffffffffff.","highlight_start":1,"highlight_end":32},{"text":"        #[doc(alias = \"SHMBaseHigh\")]","highlight_start":1,"highlight_end":38},{"text":"        #[offset(0x0bc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        shm_base_high: le32,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Virtual queue reset bit","highlight_start":1,"highlight_end":36},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// If VIRTIO_F_RING_RESET has been negotiated, writing one (0x1) to this","highlight_start":1,"highlight_end":82},{"text":"        /// register selectively resets the queue. Both read and write accesses","highlight_start":1,"highlight_end":80},{"text":"        /// apply to the queue selected by writing to `QueueSel`.","highlight_start":1,"highlight_end":66},{"text":"        #[doc(alias = \"QueueReset\")]","highlight_start":1,"highlight_end":37},{"text":"        #[offset(0x0c0)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadWrite)]","highlight_start":1,"highlight_end":29},{"text":"        queue_reset: le32,","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Configuration atomicity value","highlight_start":1,"highlight_end":42},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Reading from this register returns a value describing a version of the device-specific configuration space (see `Config`).","highlight_start":1,"highlight_end":135},{"text":"        /// The driver can then access the configuration space and, when finished, read `ConfigGeneration` again.","highlight_start":1,"highlight_end":114},{"text":"        /// If no part of the configuration space has changed between these two `ConfigGeneration` reads, the returned values are identical.","highlight_start":1,"highlight_end":141},{"text":"        /// If the values are different, the configuration space accesses were not atomic and the driver has to perform the operations again.","highlight_start":1,"highlight_end":142},{"text":"        /// See also _Basic Facilities of a Virtio Device / Device Configuration Space_.","highlight_start":1,"highlight_end":89},{"text":"        #[doc(alias = \"ConfigGeneration\")]","highlight_start":1,"highlight_end":43},{"text":"        #[offset(0x0fc)]","highlight_start":1,"highlight_end":25},{"text":"        #[access(ReadOnly)]","highlight_start":1,"highlight_end":28},{"text":"        config_generation: le32,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"device_register_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1934,"byte_end":1967,"line_start":74,"line_end":74,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"macro_rules! device_register_impl {","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"field_impl!","def_site_span":{"file_name":"virtio-spec/src/mmio.rs","byte_start":1100,"byte_end":1123,"line_start":43,"line_end":43,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! field_impl {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(non_null_convenience)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this compiler was built on 2024-04-14; consider upgrading it if it is out of date","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: use of unstable library feature 'non_null_convenience'\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mvirtio-spec/src/mmio.rs:54:51\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                self.map(|ptr| ptr.cast::<le32>().byte_add($offset))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mdevice_register_impl! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// MMIO Device Registers\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeviceRegisters {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        /// Magic Value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m458\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #117691 <https://github.com/rust-lang/rust/issues/117691> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(non_null_convenience)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this compiler was built on 2024-04-14; consider upgrading it if it is out of date\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `field_impl` which comes from the expansion of the macro `device_register_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 29 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 29 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0658`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0658`.\u001b[0m\n"}
